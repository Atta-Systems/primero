#!/usr/bin/python3


import os
import re
import shlex
import subprocess
import sys

import yaml


PROGRAM_NAME = os.path.basename(__file__)
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

KEY_PATTERN = re.compile("^[- +0-9_a-zA-Z]+$")

YAML_PATH = os.path.join(PROJECT_ROOT, "config/locales/en.yml")


def main():

    # Note: Fail fast if YAML structure or keys are bad.
    validate_yaml_structure()
    validate_yaml_keys()

    scan_project()


def validate_yaml_structure():
    yamllint_cmd = (
        'yamllint -d "{extends: default, rules: {line-length: disable}}" '
        + shlex.quote(YAML_PATH)
    )

    if os.system(yamllint_cmd) != 0:
        sys.exit(1)


def validate_yaml_keys():
    fp = open(YAML_PATH, "r")

    yaml_dict = yaml.load(fp)
    validate_yaml_dict_keys(yaml_dict)

    fp.close()


def validate_yaml_dict_keys(yaml_dict):

    for key, value in yaml_dict.items():
        assert isinstance(key, str), '"{}" is not a string'.format(str(key))
        assert KEY_PATTERN.match(key), '"{}" does not match KEY_PATTERN'.format(
            str(key)
        )

        if isinstance(value, dict):
            validate_yaml_dict_keys(value)


def scan_project():
    """
    Scan the project directory to build and return a list of keys that need to
    be preserved in the clean-up process.  Calls get_key_set() to process grep
    output and print diagnostics.
    """

    pattern = "(\\<[Ii]18n\\.t\\(|\\<t\\().*"
    command = [
        "grep",
        "-r",
        "-n",
        "-o",
        "--include=*.js",
        "--include=*.jsx",
        "--include=*.rb",
        "-E",
        "-e",
        pattern,
        PROJECT_ROOT,
    ]

    proc = subprocess.run(command, capture_output=True)
    assert len(proc.stderr) == 0, proc.stderr.decode("utf-8")

    key_set = get_key_set(proc.stdout.decode("utf-8"))

    return get_key_list(key_set)


def get_key_set(grep_output):
    """
    Iterate through the results from our grep command, printing bad keys on
    stderr and good keys on stdout.  Return the set of known used keys.
    """

    key_set = set()
    lines = grep_output.splitlines()

    for line in lines:
        f, l, r = line.split(":", maxsplit=2)

        r = r.partition("t(")[2]
        r = r.partition(")")[0]

        if not r.startswith(("'", "`", '"')):
            print(f + ":" + l + ":" + r, file=sys.stderr)
            continue

        quote = r[0]
        r = r.partition(quote)[2]
        r = r.partition(quote)[0]

        key = ""
        for k in r.split("."):

            if not KEY_PATTERN.match(k):
                print(f + ":" + l + ":" + r, file=sys.stderr)
                break

            key += ("." + k) if len(key) > 0 else k

        if len(key) > 0:
            key_set.add(key)

    for k in key_set:
        print(k)

    return key_set


def get_key_list(key_set):
    """
    Build and return a list of keys that should be preserved during the
    clean-up operation.
    """

    result = []

    key_list = sorted(key_set, key=len)
    assert isinstance(key_list, list)

    for key in key_list:

        prefix = ""
        for subkey in key.split("."):
            prefix += ("." + subkey) if len(prefix) > 0 else subkey

            if prefix in result:
                break

        if prefix not in result:
            assert prefix == key
            result.append(prefix)

    assert len(result) == len(set(result))

    return result


if __name__ == "__main__":
    main()
