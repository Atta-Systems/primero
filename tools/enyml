#!/usr/bin/python3


import os
import re
import shlex
import subprocess
import sys

import yaml


PROGRAM_NAME = os.path.basename(__file__)
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

KEY_PATTERN = re.compile("^[- +0-9_a-zA-Z]+$")

YAML_PATH = os.path.join(PROJECT_ROOT, "config/locales/en.yml")


def main():

    # Note: Fail fast if YAML structure or keys are bad.
    validate_yaml_structure()
    validate_yaml_keys()

    key_list = scan_project()

    write_yaml(key_list)


def validate_yaml_structure():
    """
    Use "yamllint" to validate the "en.yml" file.  Exit with status 1 if
    validation fails.
    """

    yamllint_cmd = (
        'yamllint -d "{extends: default, rules: {line-length: disable}}" '
        + shlex.quote(YAML_PATH)
    )

    if os.system(yamllint_cmd) != 0:
        sys.exit(1)


def validate_yaml_keys():
    """
    Make sure that all keys in the "en.yml" file conform to a predictable
    pattern.  Such a pattern allows us to search for keys effectively.  Exit
    with status 1 if a key does not match the KEY_PATTERN.
    """

    fp = open(YAML_PATH, "r")

    yaml_dict = yaml.load(fp)
    validate_yaml_dict_keys(yaml_dict)

    fp.close()


def validate_yaml_dict_keys(yaml_dict):
    """
    Recursively walk the dictionary of translation keys and validate each key.
    """

    for key, value in yaml_dict.items():
        assert isinstance(key, str), '"{}" is not a string'.format(str(key))
        assert KEY_PATTERN.match(key), '"{}" does not match KEY_PATTERN'.format(
            str(key)
        )

        if isinstance(value, dict):
            validate_yaml_dict_keys(value)


def scan_project():
    """
    Scan the project directory to build and return a list of keys that need to
    be preserved in the clean-up process.  Calls get_key_set() to process grep
    output and print diagnostics.
    """

    pattern = "(\\<[Ii]18n\\.t\\(|\\<t\\().*"
    command = [
        "grep",
        "-r",
        "-n",
        "-o",
        "--include=*.js",
        "--include=*.jsx",
        "--include=*.rb",
        "-E",
        "-e",
        pattern,
        PROJECT_ROOT,
    ]

    proc = subprocess.run(command, capture_output=True)
    assert len(proc.stderr) == 0, proc.stderr.decode("utf-8")

    key_set = get_key_set(proc.stdout.decode("utf-8"))

    return get_key_list(key_set)


def get_key_set(grep_output):
    """
    Iterate through the results from our grep command, printing bad keys on
    stderr and good keys on stdout.  Return the set of known used keys.
    """

    key_set = set()
    lines = grep_output.splitlines()

    for line in lines:
        f, l, r = line.split(":", maxsplit=2)

        r = r.partition("t(")[2]
        r = r.partition(")")[0]

        if not r.startswith(("'", "`", '"')):
            echoerr("indeterminate:" + f + ":" + l + ":" + r)
            continue

        quote = r[0]
        r = r.partition(quote)[2]
        r = r.partition(quote)[0]

        key = ""
        msg = "indeterminate"
        for k in r.split("."):

            if not KEY_PATTERN.match(k):
                echoerr(msg + ":" + f + ":" + l + ":" + r)
                break

            key += ("." + k) if len(key) > 0 else k
            msg = "partial"

        if len(key) > 0:
            key_set.add(key)

    for k in key_set:
        print(k)

    return key_set


def get_key_list(key_set):
    """
    Build and return a list of keys that should be preserved during the
    clean-up operation.
    """

    result = []

    key_list = sorted(key_set, key=len)
    assert isinstance(key_list, list)

    for key in key_list:

        prefix = ""
        for subkey in key.split("."):
            prefix += ("." + subkey) if len(prefix) > 0 else subkey

            if prefix in result:
                break

        if prefix not in result:
            assert prefix == key
            result.append(prefix)

    assert len(result) == len(set(result))

    return result


def write_yaml(key_list):
    """
    Re-write the "en.yml" file, removing any keys that aren't present in the
    key_list argument.
    """

    with open(YAML_PATH, "r") as fp:
        yaml_dict = yaml.load(fp)

    yaml_dict = yaml_dict["en"]
    result = dict()

    for key in key_list:

        src = yaml_dict
        dest = result

        for i, subkey in enumerate(key.split(".")):

            if subkey not in src:
                echoerr("undefined:" + key)
                break

            if i == (len(key.split(".")) - 1):
                dest[subkey] = src[subkey]
                continue

            if isinstance(src[subkey], dict):
                src = src[subkey]

                if subkey not in dest:
                    dest[subkey] = dict()

                dest = dest[subkey]
                continue

            dest[subkey] = src[subkey]

    tmp = dict()
    tmp["en"] = result
    result = tmp

    prune_empty(result)

    with open(YAML_PATH, "w") as fp:
        yaml.dump(
            result,
            fp,
            allow_unicode=True,
            default_flow_style=False,
            explicit_start=True,
        )


def prune_empty(dictionary):
    """
    Recursively walk through dictionary and prune key/value pairs where the
    value is an empty dict().
    """

    keys = [k for k, v in dictionary.items() if v == {}]

    for k in keys:
        del dictionary[k]

    for k, v in dictionary.items():

        if isinstance(v, dict):
            prune_empty(v)


def echoerr(msg):
    print(PROGRAM_NAME + ":" + msg, file=sys.stderr)


if __name__ == "__main__":
    main()
